模式要点：
1、让设计模式自然而然地出现在你的设计中，而不是为了使用而使用
2、设计模式并非僵化的教条；你可以依据自己的需要采用和调整
3、总是使用满足需要的最简单解决方案，不管它用不用模式
4、学习设计模式的类目，可以帮你自己熟悉这些模式以及它们之间的关系
5、模式的分类（或类目）是将模式分成不同的族群，如果这么做对你有帮助，就采用吧
6、你必须相当专注才能够成为一个模式的作家：这需要时间也需要耐心，同时还必须乐意做大量的精化工作
7、请牢记：你所遇到大多数的模式都是现有模式的变体，而非新的模式
8、模式能够为你带来的最大好处之一是：让你的团队拥有共享词汇
9、任何社群都有自己的行话，模式社群也是如此。别让这些行话绊着，在读完这本书之后，你已经能够应用大部分行话了

模式分类：
创建型：
    Singleton（单例模式）              确保有且只有一个对象被创建
    Prototype（原型）                 复制原型对象来创建一个和原型相同或相似的新对象
    Abstract Factory（抽象工厂模式）    允许客户创建对象的家族，而无需指定他们的具体类
    Factory Method（工厂方法模式）      由子类决定要创建的具体类是哪一个
    Builder（建造者）                  将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

行为型：
    Template Method（模板方法模式）     由子类决定如何实现一个算法的步骤
    Iterator（迭代器模式）             在对象的集合之中游走，而不暴露集合的实现
    Command（命令模式）                封装请求成为对象
    Observer（观察者模式）             让对象能够在状态改变时被通知
    State（状态模式）                  封装了基于状态的行为，并使用委托在行为之间切换
    Strategy（策略模式）               封装可以互换的行为，并使用委托来决定要使用哪一个
    Chain Of Responsibility（责任链） 解耦发送者与请求处理者，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链
    Mediator（中介者）                定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散
    Visitor（访问者）                 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，将对数据的操作与数据结构进行分离
    Memento（备忘录）                 捕获一个对象的内部状态，并在该对象之外保存这个状态，以便将该对象恢复到原先保存的状态
    Interpreter（解释器）             设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例

结构型：
    Decorator（装饰者模式）            包装一个对象，以扩展新的行为
    Proxy（代理模式）                  包装对象，以控制对此对象的访问或其他操作（面向切面实现）
    Composite（组合模式）              客户用一致的方式处理对象集合和单个对象
    facade（外观模式）                 简化一群类的接口
    Adapter（适配器模式）              封装对象并提供不同的接口，让原本接口不兼容的类可以合作无间
    Bridge（桥接）                    将抽象化与实现化脱耦。用组合关系代替继承关系（同一物品在不同角度的分类，如 白色的正方形，黑色的三角形）
    Flyweight（享元）                 共享已经存在的对象来大幅度减少需要创建的对象数量（redis缓存）